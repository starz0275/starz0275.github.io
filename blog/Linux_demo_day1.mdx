---
slug: Jean-blog-post
title: Linux项目学习第一天
authors: [Xujing Nie] 
tags: [Linux,项目]
---



# 物联网边缘网关开发实录：从 STM32 到 Linux 串口编程 (V1.0)

## 1. 项目背景与目标

为了深入掌握嵌入式 Linux 应用开发，我启动了一个名为 **“基于多线程与 I/O 多路复用的物联网边缘计算网关”** 的项目。

该项目的核心目标是构建一个能够高效连接底层感知设备（STM32）与上层云端应用（PC/Server）的中间件。它不仅仅是一个简单的数据透传工具，更是一个包含**数据解析、环形缓冲、多线程并发、网络转发**的完整边缘计算节点。

本文记录了 **V1.0 版本（最小可行性系统）** 的开发过程与技术沉淀。

## 2. 系统架构 (V1.0)

在 V1.0 阶段，主要任务是打通 **硬件层（STM32）** 到 **传输层（Linux 串口）** 的数据链路。

**数据流向图：**

```
[STM32 单片机]  ---->  [USB转串口线]  ---->  [VMware Linux]  ---->  [终端显示]
(模拟光照数据)         (物理传输层)          (应用层 C程序)         (解析结果)
```

**环境配置：**

- **硬件**：STM32F103 开发板 + 光敏电阻（模拟）

- **宿主机**：Windows 11 + VMware Workstation

  **开发环境**：Ubuntu 18.04 LTS + GCC + VS Code

## 3. 核心技术实现

### 3.1 固件端：模拟数据源与协议打包

为了在硬件传感器未完全就绪的情况下先行开发软件业务，我在 STM32 端采用了 **Mock Data（模拟数据）** 的设计思路。

- **模拟数据生成**：在主循环中让光照数值在 `0~4000` 之间线性循环，便于接收端通过数据连续性判断是否丢包。
- **底层驱动**：使用 STM32 HAL 库的 `HAL_UART_Transmit` 实现阻塞式发送。

### 3.2 协议层：自定义通信协议设计

为了解决串口通信中常见的“粘包”和“数据错位”问题，我设计了一套基于 **TLV (Type-Length-Value)** 思想的二进制通信协议。

**协议帧结构定义 (`protocol.h`)：**

| 帧头 (2B)   | 命令 (1B) | 长度 (1B) | 数据载荷 (N Byte)                | 校验和 (1B) |
| ----------- | --------- | --------- | -------------------------------- | ----------- |
| `0xAA 0x55` | `0x01`    | `0x04`    | `[光照低] [光照高] [LED] [保留]` | Checksum    |

**关键技术点：**

- **字节对齐**：在定义结构体时使用了 `__attribute__((packed))`，强制取消编译器的内存对齐优化，确保结构体在内存中的布局与网络传输字节流完全一致。

### 3.3 应用层：Linux 串口编程

这是 V1.0 版本最核心的工作。在 Linux 环境下，一切皆文件。通过操作 `/dev/ttyACM0` 设备文件，实现了数据的实时读取。

**Termios 配置要点：** 为了确保传输二进制数据时不被操作系统“篡改”（例如将 `0x0D` 自动转换为 `0x0A`），必须将串口配置为 **Raw Mode（原始模式）**：

```
// 关键配置代码片段
struct termios options;
tcgetattr(fd, &options);

// 关闭规范模式、回显、信号响应
options.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
// 关闭软件流控
options.c_iflag &= ~(IXON | IXOFF | IXANY); 
// 关闭回车转换
options.c_iflag &= ~(ICRNL | INLCR);
// 关闭输出处理
options.c_oflag &= ~OPOST; 

tcsetattr(fd, TCSANOW, &options);
```

### 3.4 算法层：状态机解析

在接收端，实现了一个简单的状态机逻辑。程序在接收到的 HEX 数据流中实时检索帧头 `0xAA 0x55`，一旦锁定帧头，即读取后续指令与数据，并进行校验。

**解析效果：** Linux 终端成功接收并还原了 STM32 发送的物理数据：

```
[收到数据包] ==================
  原始 HEX: AA 55 01 04 C8 00 00 00 C2
  >>> 传感器上报 <<<
  光照强度: 200
  LED 状态: OFF
```

## 4. 遇到的坑与解决方案

1. **WSL 2 的串口驱动问题**： 起初尝试在 WSL 2 环境下开发，遭遇了严重的 `Input/output error`。分析发现 WSL 对 USB 转串口设备的直接映射在高波特率下极不稳定。 **解决**：果断迁移至 **VMware 虚拟机**，利用其 USB 物理透传功能，彻底解决了驱动不稳的问题。
2. **Keil 编译器兼容性**： 在移植协议头文件到 STM32 时，遇到了 C90 标准不支持柔性数组 `data[0]` 的报错。 **解决**：修改为 `data[1]` 或开启 C99 模式，解决了编译错误。

